"use strict";
var BasicPubSubClient_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasicPubSubClient = void 0;
const tslib_1 = require("tslib");
const connection_1 = require("@d-fischer/connection");
const logger_1 = require("@d-fischer/logger");
const shared_utils_1 = require("@d-fischer/shared-utils");
const typed_event_emitter_1 = require("@d-fischer/typed-event-emitter");
const auth_1 = require("@twurple/auth");
const common_1 = require("@twurple/common");
/**
 * A client for the Twitch PubSub interface.
 */
let BasicPubSubClient = BasicPubSubClient_1 = class BasicPubSubClient extends typed_event_emitter_1.EventEmitter {
    /**
     * Creates a new PubSub client.
     *
     * @param options
     *
     * @expandParams
     */
    constructor(options) {
        super();
        // topic => token
        this._topics = new Map();
        this._pingOnInactivity = 60;
        this._pingTimeout = 10;
        this._onPong = this.registerInternalEvent();
        this._onResponse = this.registerInternalEvent();
        /**
         * Fires when a message that matches your listening topics is received.
         *
         * @eventListener
         * @param topic The name of the topic.
         * @param message The message data.
         */
        this.onMessage = this.registerEvent();
        /**
         * Fires when the client finishes establishing a connection to the PubSub server.
         *
         * @eventListener
         */
        this.onConnect = this.registerEvent();
        /**
         * Fires when the client closes its connection to the PubSub server.
         *
         * @eventListener
         * @param isError Whether the cause of the disconnection was an error. A reconnect will be attempted if this is true.
         */
        this.onDisconnect = this.registerEvent();
        /**
         * Fires when the client receives a pong message from the PubSub server.
         *
         * @eventListener
         * @param latency The current latency to the server, in milliseconds.
         * @param requestTimestampe The time the ping request was sent to the PubSub server.
         */
        this.onPong = this.registerEvent();
        this._logger = logger_1.createLogger({
            name: 'twurple:pubsub',
            emoji: true,
            ...options === null || options === void 0 ? void 0 : options.logger
        });
        this._connection = new connection_1.PersistentConnection(connection_1.WebSocketConnection, { hostName: 'pubsub-edge.twitch.tv', port: 443, secure: true }, { logger: this._logger }, { wsOptions: options === null || options === void 0 ? void 0 : options.wsOptions });
        this._connection.onConnect(async () => {
            this._logger.info('Connection established');
            await this._resendListens();
            if (this._topics.size) {
                this._logger.info('Listened to previously registered topics');
                this._logger.debug(`Previously registered topics: ${Array.from(this._topics.keys()).join(', ')}`);
            }
            this._startPingCheckTimer();
            this.emit(this.onConnect);
        });
        this._connection.onReceive((line) => {
            this._receiveMessage(line);
            this._startPingCheckTimer();
        });
        this._connection.onDisconnect((manually, reason) => {
            if (this._pingCheckTimer) {
                clearTimeout(this._pingCheckTimer);
            }
            if (this._pingTimeoutTimer) {
                clearTimeout(this._pingTimeoutTimer);
            }
            this.removeInternalListener();
            if (manually) {
                this._logger.info('Disconnected');
            }
            else {
                if (reason) {
                    this._logger.error(`Disconnected unexpectedly: ${reason.message}`);
                }
                else {
                    this._logger.error('Disconnected unexpectedly');
                }
            }
            this.emit(this.onDisconnect, manually, reason);
        });
    }
    /**
     * Listens to one or more topics.
     *
     * @param topics A topic or a list of topics to listen to.
     * @param tokenResolvable An access token, an AuthProvider or a function that returns a token.
     * @param scope The scope necessary for the topic(s).
     */
    async listen(topics, tokenResolvable, scope) {
        if (typeof topics === 'string') {
            topics = [topics];
        }
        const wrapped = BasicPubSubClient_1._wrapResolvable(tokenResolvable, scope);
        for (const topic of topics) {
            this._topics.set(topic, wrapped);
        }
        if (this.isConnected) {
            await this._sendListen(topics, await this._resolveToken(wrapped));
        }
    }
    /**
     * Removes one or more topics from the listener.
     *
     * @param topics A topic or a list of topics to not listen to anymore.
     */
    async unlisten(topics) {
        if (typeof topics === 'string') {
            topics = [topics];
        }
        for (const topic of topics) {
            this._topics.delete(topic);
        }
        if (this.isConnected) {
            await this._sendUnlisten(topics);
        }
    }
    /**
     * Connects to the PubSub interface.
     */
    async connect() {
        if (!this._connection.isConnected && !this._connection.isConnecting) {
            this._logger.info('Connecting...');
            await this._connection.connect();
        }
    }
    /**
     * Disconnects from the PubSub interface.
     */
    async disconnect() {
        this._logger.info('Disconnecting...');
        await this._connection.disconnect();
    }
    /**
     * Reconnects to the PubSub interface.
     */
    async reconnect() {
        await this.disconnect();
        await this.connect();
    }
    /**
     * Checks whether the client is currently connecting to the server.
     */
    get isConnecting() {
        return this._connection.isConnecting;
    }
    /**
     * Checks whether the client is currently connected to the server.
     */
    get isConnected() {
        return this._connection.isConnected;
    }
    /** @private */
    get hasAnyTopics() {
        return this._topics.size > 0;
    }
    async _sendListen(topics, accessToken) {
        await this._sendNonced({
            type: 'LISTEN',
            data: {
                topics,
                auth_token: accessToken
            }
        });
    }
    async _sendUnlisten(topics) {
        await this._sendNonced({
            type: 'UNLISTEN',
            data: {
                topics
            }
        });
    }
    static _wrapResolvable(resolvable, scope) {
        switch (typeof resolvable) {
            case 'object': {
                if ('type' in resolvable) {
                    return resolvable;
                }
                return {
                    type: 'provider',
                    provider: resolvable,
                    scopes: scope ? [scope] : []
                };
            }
            case 'string': {
                return {
                    type: 'static',
                    token: resolvable
                };
            }
            case 'function': {
                return {
                    type: 'function',
                    function: resolvable
                };
            }
            default: {
                throw new common_1.HellFreezesOverError(`Passed unknown type to wrapResolvable: ${typeof resolvable}`);
            }
        }
    }
    async _resolveToken(resolvable) {
        switch (resolvable.type) {
            case 'provider': {
                const { provider, scopes } = resolvable;
                const { accessToken } = await auth_1.getValidTokenFromProvider(provider, scopes, this._logger);
                return accessToken.accessToken;
            }
            case 'function': {
                return await resolvable.function();
            }
            case 'static': {
                return resolvable.token;
            }
            default: {
                throw new common_1.HellFreezesOverError(`Passed unknown type to resolveToken: ${resolvable.type}`);
            }
        }
    }
    async _resendListens() {
        const topicsByTokenResolvable = new Map();
        for (const [topic, tokenResolvable] of this._topics) {
            if (topicsByTokenResolvable.has(tokenResolvable)) {
                topicsByTokenResolvable.get(tokenResolvable).push(topic);
            }
            else {
                topicsByTokenResolvable.set(tokenResolvable, [topic]);
            }
        }
        const topicsByToken = new Map();
        for (const [tokenResolvable, topics] of topicsByTokenResolvable) {
            const token = await this._resolveToken(tokenResolvable);
            if (topicsByToken.has(token)) {
                topicsByToken.get(token).push(...topics);
            }
            else {
                topicsByToken.set(token, topics);
            }
        }
        return await Promise.all(Array.from(topicsByToken.entries()).map(async ([token, topics]) => await this._sendListen(topics, token)));
    }
    async _sendNonced(packet) {
        await new Promise((resolve, reject) => {
            const nonce = Math.random().toString(16).slice(2);
            const responseListener = this._onResponse((recvNonce, error) => {
                if (recvNonce === nonce) {
                    if (error) {
                        reject(new Error(`Error sending nonced ${packet.type} packet: ${error}`));
                    }
                    else {
                        resolve();
                    }
                    responseListener.unbind();
                }
            });
            packet.nonce = nonce;
            this._sendPacket(packet);
        });
    }
    _receiveMessage(dataStr) {
        this._logger.debug(`Received message: ${dataStr}`);
        const data = JSON.parse(dataStr);
        switch (data.type) {
            case 'PONG': {
                this.emit(this._onPong);
                break;
            }
            case 'RECONNECT': {
                void this.reconnect();
                break;
            }
            case 'RESPONSE': {
                this.emit(this._onResponse, data.nonce, data.error);
                break;
            }
            case 'MESSAGE': {
                this.emit(this.onMessage, data.data.topic, JSON.parse(data.data.message));
                break;
            }
            default: {
                this._logger.warn(`PubSub connection received unexpected message type: ${data.type}`);
            }
        }
    }
    _sendPacket(data) {
        const dataStr = JSON.stringify(data);
        this._logger.debug(`Sending message: ${dataStr}`);
        this._connection.sendLine(dataStr);
    }
    _pingCheck() {
        const pingTime = Date.now();
        this._onPong(() => {
            const latency = Date.now() - pingTime;
            this.emit(this.onPong, latency, pingTime);
            this._logger.info(`Current latency: ${latency}ms`);
            if (this._pingTimeoutTimer) {
                clearTimeout(this._pingTimeoutTimer);
            }
            this.removeInternalListener(this._onPong);
        });
        this._pingTimeoutTimer = setTimeout(async () => {
            this._logger.error('Ping timeout');
            this.removeInternalListener(this._onPong);
            this._connection.assumeExternalDisconnect();
        }, this._pingTimeout * 1000);
        this._sendPacket({ type: 'PING' });
    }
    _startPingCheckTimer() {
        if (this._pingCheckTimer) {
            clearInterval(this._pingCheckTimer);
        }
        if (this._connection.isConnected) {
            this._pingCheckTimer = setInterval(() => this._pingCheck(), this._pingOnInactivity * 1000);
        }
        else {
            this._pingCheckTimer = undefined;
        }
    }
};
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], BasicPubSubClient.prototype, "_logger", void 0);
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], BasicPubSubClient.prototype, "_topics", void 0);
BasicPubSubClient = BasicPubSubClient_1 = tslib_1.__decorate([
    common_1.rtfm('pubsub', 'BasicPubSubClient')
], BasicPubSubClient);
exports.BasicPubSubClient = BasicPubSubClient;
