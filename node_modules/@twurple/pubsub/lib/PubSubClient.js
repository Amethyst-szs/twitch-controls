"use strict";
var PubSubClient_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PubSubClient = void 0;
const tslib_1 = require("tslib");
const shared_utils_1 = require("@d-fischer/shared-utils");
const auth_1 = require("@twurple/auth");
const common_1 = require("@twurple/common");
const BasicPubSubClient_1 = require("./BasicPubSubClient");
const SingleUserPubSubClient_1 = require("./SingleUserPubSubClient");
/**
 * A high level PubSub client attachable to a multiple users.
 */
let PubSubClient = PubSubClient_1 = class PubSubClient {
    /**
     * Creates a new PubSub client.
     *
     * @param rootClient A previously existing BasicPubSubClient instance.
     *
     * If not given, one will be created with the default options.
     */
    constructor(rootClient) {
        this._userClients = new Map();
        this._rootClient = rootClient !== null && rootClient !== void 0 ? rootClient : new BasicPubSubClient_1.BasicPubSubClient();
    }
    /**
     * Attaches a new user to the listener and returns the user ID for convenience.
     *
     * @param authProvider The authentication provider for the user.
     * @param user The user that the client will be attached to.
     *
     * This should only be passed manually if you fetched the token info for the `authProvider` before.
     *
     * If not given, the user will be determined from the `authProvider`.
     */
    async registerUserListener(authProvider, user) {
        const userId = await PubSubClient_1._getCorrectUserId(authProvider, user);
        this._userClients.set(userId, new SingleUserPubSubClient_1.SingleUserPubSubClient({ authProvider, pubSubClient: this._rootClient }));
        return userId;
    }
    /** @private */
    getUserListener(user) {
        const userId = common_1.extractUserId(user);
        if (!this._userClients.has(userId)) {
            throw new Error(`No API client registered for user ID ${userId}
Register one using:

\tpubSubClient.registerUserListener(apiClient);`);
        }
        return this._userClients.get(userId);
    }
    /**
     * Adds a listener to AutoMod queue events to the client.
     *
     * @param user The user the event will be subscribed for.
     * @param channel The channel to listen to.
     * @param callback A function to be called when an AutoMod queue event is sent to the user.
     *
     * It receives a {@PubSubAutoModQueueMessage} object.
     */
    async onAutoModQueue(user, channel, callback) {
        return await this.getUserListener(user).onAutoModQueue(channel, callback);
    }
    /**
     * Adds a listener to bits events to the client.
     *
     * @param user The user the event will be subscribed for.
     * @param callback A function to be called when a bits event happens in the user's channel.
     *
     * It receives a {@PubSubBitsMessage} object.
     */
    async onBits(user, callback) {
        return await this.getUserListener(user).onBits(callback);
    }
    /**
     * Adds a listener to bits badge unlock events to the client.
     *
     * @param user The user the event will be subscribed for.
     * @param callback A function to be called when a bit badge is unlocked in the user's channel.
     *
     * It receives a {@PubSubBitsBadgeUnlockMessage} object.
     */
    async onBitsBadgeUnlock(user, callback) {
        return await this.getUserListener(user).onBitsBadgeUnlock(callback);
    }
    /**
     * Adds a listener to mod action events to the client.
     *
     * @param user The user the event will be subscribed for.
     * @param channel The channel the event will be subscribed for.
     * @param callback A function to be called when a mod action event is sent to the user.
     *
     * It receives a {@PubSubChatModActionMessage} object.
     */
    async onModAction(user, channel, callback) {
        return await this.getUserListener(user).onModAction(channel, callback);
    }
    /**
     * Adds a listener to redemption events to the client.
     *
     * @param user The user the event will be subscribed for.
     * @param callback A function to be called when a channel point reward is redeemed in the user's channel.
     *
     * It receives a {@PubSubRedemptionMessage} object.
     */
    async onRedemption(user, callback) {
        return await this.getUserListener(user).onRedemption(callback);
    }
    /**
     * Adds a listener to subscription events to the client.
     *
     * @param user The user the event will be subscribed for.
     * @param callback A function to be called when a subscription event happens in the user's channel.
     *
     * It receives a {@PubSubSubscriptionMessage} object.
     */
    async onSubscription(user, callback) {
        return await this.getUserListener(user).onSubscription(callback);
    }
    /**
     * Adds a listener to user moderation events to the client.
     *
     * @param user The user the event will be subscribed for.
     * @param channel The channel to listen to.
     * @param callback A function to be called when a user moderation event is sent to the user.
     *
     * It receives a {@PubSubUserModerationNotificationMessage} object.
     */
    async onUserModeration(user, channel, callback) {
        return await this.getUserListener(user).onUserModeration(channel, callback);
    }
    /**
     * Adds a listener to whisper events to the client.
     *
     * @param user The user the event will be subscribed for.
     * @param callback A function to be called when a whisper is sent to the user.
     *
     * It receives a {@PubSubWhisperMessage} object.
     */
    async onWhisper(user, callback) {
        return await this.getUserListener(user).onWhisper(callback);
    }
    /**
     * Adds a listener for arbitrary/undocumented events to the client.
     *
     * @param user The user the event will be subscribed for.
     * @param topic The topic to subscribe to.
     * @param callback A function to be called when a custom event is sent to the user.
     *
     * It receives a {@PubSubCustomMessage} object.
     * @param scope An optional scope if the topic requires it.
     * @param channel An optional second userId if the topic requires it, usually a channel.
     */
    async onCustomTopic(user, topic, callback, scope, channel) {
        return await this.getUserListener(user).onCustomTopic(topic, callback, scope, channel);
    }
    static async _getCorrectUserId(authProvider, user) {
        if (user) {
            return common_1.extractUserId(user);
        }
        else {
            if (authProvider.tokenType === 'app') {
                throw new auth_1.InvalidTokenTypeError('App tokens are not supported by PubSubClient; you need to pass authentication representing a user.');
            }
            const { tokenInfo } = await auth_1.getValidTokenFromProvider(authProvider);
            if (!tokenInfo.userId) {
                throw new auth_1.InvalidTokenTypeError('Could not determine a user ID for your token; you might be trying to disguise an app token as a user token.');
            }
            return tokenInfo.userId;
        }
    }
};
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], PubSubClient.prototype, "_rootClient", void 0);
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], PubSubClient.prototype, "_userClients", void 0);
PubSubClient = PubSubClient_1 = tslib_1.__decorate([
    common_1.rtfm('pubsub', 'PubSubClient')
], PubSubClient);
exports.PubSubClient = PubSubClient;
