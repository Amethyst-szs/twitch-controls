"use strict";
var SingleUserPubSubClient_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SingleUserPubSubClient = void 0;
const tslib_1 = require("tslib");
const shared_utils_1 = require("@d-fischer/shared-utils");
const auth_1 = require("@twurple/auth");
const common_1 = require("@twurple/common");
const BasicPubSubClient_1 = require("./BasicPubSubClient");
const PubSubAutoModQueueMessage_1 = require("./messages/PubSubAutoModQueueMessage");
const PubSubBitsBadgeUnlockMessage_1 = require("./messages/PubSubBitsBadgeUnlockMessage");
const PubSubBitsMessage_1 = require("./messages/PubSubBitsMessage");
const PubSubChatModActionMessage_1 = require("./messages/PubSubChatModActionMessage");
const PubSubCustomMessage_1 = require("./messages/PubSubCustomMessage");
const PubSubRedemptionMessage_1 = require("./messages/PubSubRedemptionMessage");
const PubSubSubscriptionMessage_1 = require("./messages/PubSubSubscriptionMessage");
const PubSubUserModerationNotificationMessage_1 = require("./messages/PubSubUserModerationNotificationMessage");
const PubSubWhisperMessage_1 = require("./messages/PubSubWhisperMessage");
const PubSubListener_1 = require("./PubSubListener");
/**
 * A higher level PubSub client attached to a single user.
 */
let SingleUserPubSubClient = SingleUserPubSubClient_1 = class SingleUserPubSubClient {
    /**
     * Creates a new Twitch PubSub client.
     *
     * @expandParams
     */
    constructor({ authProvider, pubSubClient, logger }) {
        this._listeners = new Map();
        this._authProvider = authProvider;
        this._pubSubClient = pubSubClient !== null && pubSubClient !== void 0 ? pubSubClient : new BasicPubSubClient_1.BasicPubSubClient({ logger });
        this._pubSubClient.onMessage(async (topic, messageData) => {
            const [type, userId, ...args] = topic.split('.');
            if (this._listeners.has(topic) && userId === (await this._getUserId())) {
                const message = SingleUserPubSubClient_1._parseMessage(type, args, messageData);
                for (const listener of this._listeners.get(topic)) {
                    listener.call(message);
                }
            }
        });
    }
    /**
     * Adds a listener to AutoMod queue events to the client.
     *
     * @param channel The channel to listen to.
     * @param callback A function to be called when an AutoMod queue event is sent to the user.
     *
     * It receives a {@PubSubAutoModQueueMessage} object.
     */
    async onAutoModQueue(channel, callback) {
        return await this._addListener('automod-queue', callback, 'channel:moderate', common_1.extractUserId(channel));
    }
    /**
     * Adds a listener to bits events to the client.
     *
     * @param callback A function to be called when a bits event happens in the user's channel.
     *
     * It receives a {@PubSubBitsMessage} object.
     */
    async onBits(callback) {
        return await this._addListener('channel-bits-events-v2', callback, 'bits:read');
    }
    /**
     * Adds a listener to bits badge unlock events to the client.
     *
     * @param callback A function to be called when a bit badge is unlocked in the user's channel.
     *
     * It receives a {@PubSubBitsBadgeUnlockMessage} object.
     */
    async onBitsBadgeUnlock(callback) {
        return await this._addListener('channel-bits-badge-unlocks', callback, 'bits:read');
    }
    /**
     * Adds a listener to mod action events to the client.
     *
     * @param channel The channel to listen to.
     * @param callback A function to be called when a mod action event is sent to the user.
     *
     * It receives a {@PubSubChatModActionMessage} object.
     */
    async onModAction(channel, callback) {
        return await this._addListener('chat_moderator_actions', callback, 'channel:moderate', common_1.extractUserId(channel));
    }
    /**
     * Adds a listener to redemption events to the client.
     *
     * @param callback A function to be called when a channel point reward is redeemed in the user's channel.
     *
     * It receives a {@PubSubRedemptionMessage} object.
     */
    async onRedemption(callback) {
        return await this._addListener('channel-points-channel-v1', callback, 'channel:read:redemptions');
    }
    /**
     * Adds a listener to user moderation events to the client.
     *
     * @param channel The channel to listen to.
     * @param callback A function to be called when a user moderation event is sent to the user.
     *
     * It receives a {@PubSubUserModerationNotificationMessage} object.
     */
    async onUserModeration(channel, callback) {
        return await this._addListener('user-moderation-notifications', callback, 'chat:read', common_1.extractUserId(channel));
    }
    /**
     * Adds a listener to subscription events to the client.
     *
     * @param callback A function to be called when a subscription event happens in the user's channel.
     *
     * It receives a {@PubSubSubscriptionMessage} object.
     */
    async onSubscription(callback) {
        return await this._addListener('channel-subscribe-events-v1', callback, 'channel_subscriptions');
    }
    /**
     * Adds a listener to whisper events to the client.
     *
     * @param callback A function to be called when a whisper is sent to the user.
     *
     * It receives a {@PubSubWhisperMessage} object.
     */
    async onWhisper(callback) {
        return await this._addListener('whispers', callback, 'whispers:read');
    }
    /**
     * Adds a listener for arbitrary/undocumented events to the client.
     *
     * @param topic The topic to subscribe to.
     * @param callback A function to be called when a custom event is sent to the user.
     *
     * It receives a {@PubSubCustomMessage} object.
     * @param scope An optional scope if the topic requires it.
     * @param channelId The ID of the channel to listen to, if the topic requires it.
     */
    async onCustomTopic(topic, callback, scope, channelId) {
        if (channelId) {
            return await this._addListener(topic, callback, scope, common_1.extractUserId(channelId));
        }
        else {
            return await this._addListener(topic, callback, scope);
        }
    }
    /**
     * Removes a listener from the client.
     *
     * @param listener A listener returned by one of the `add*Listener` methods.
     */
    async removeListener(listener) {
        if (this._listeners.has(listener.topic)) {
            const newListeners = this._listeners.get(listener.topic).filter(l => l !== listener);
            if (newListeners.length === 0) {
                this._listeners.delete(listener.topic);
                await this._pubSubClient.unlisten(`${listener.topic}.${listener.userId}`);
                if (!this._pubSubClient.hasAnyTopics &&
                    (this._pubSubClient.isConnected || this._pubSubClient.isConnecting)) {
                    await this._pubSubClient.disconnect();
                }
            }
            else {
                this._listeners.set(listener.topic, newListeners);
            }
        }
    }
    static _parseMessage(type, args, messageData) {
        switch (type) {
            case 'automod-queue': {
                return new PubSubAutoModQueueMessage_1.PubSubAutoModQueueMessage(messageData, args[0]);
            }
            case 'channel-bits-events-v2': {
                return new PubSubBitsMessage_1.PubSubBitsMessage(messageData);
            }
            case 'channel-bits-badge-unlocks': {
                return new PubSubBitsBadgeUnlockMessage_1.PubSubBitsBadgeUnlockMessage(messageData);
            }
            case 'channel-points-channel-v1': {
                return new PubSubRedemptionMessage_1.PubSubRedemptionMessage(messageData);
            }
            case 'channel-subscribe-events-v1': {
                return new PubSubSubscriptionMessage_1.PubSubSubscriptionMessage(messageData);
            }
            case 'chat_moderator_actions': {
                return new PubSubChatModActionMessage_1.PubSubChatModActionMessage(messageData, args[0]);
            }
            case 'user-moderation-notifications': {
                return new PubSubUserModerationNotificationMessage_1.PubSubUserModerationNotificationMessage(messageData, args[0]);
            }
            case 'whispers': {
                return new PubSubWhisperMessage_1.PubSubWhisperMessage(messageData);
            }
            default:
                return new PubSubCustomMessage_1.PubSubCustomMessage(messageData);
        }
    }
    async _getUserId() {
        if (this._userId) {
            return this._userId;
        }
        const { tokenInfo } = await auth_1.getValidTokenFromProvider(this._authProvider);
        if (!tokenInfo.userId) {
            throw new auth_1.InvalidTokenTypeError('Could not determine a user ID for your token; you might be trying to disguise an app token as a user token.');
        }
        return (this._userId = tokenInfo.userId);
    }
    async _addListener(type, callback, scope, ...additionalParams) {
        await this._pubSubClient.connect();
        const userId = await this._getUserId();
        const topicName = [type, userId, ...additionalParams].join('.');
        const listener = new PubSubListener_1.PubSubListener(topicName, userId, callback, this);
        if (this._listeners.has(topicName)) {
            this._listeners.get(topicName).push(listener);
        }
        else {
            this._listeners.set(topicName, [listener]);
            await this._pubSubClient.listen(topicName, this._authProvider, scope);
        }
        return listener;
    }
};
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], SingleUserPubSubClient.prototype, "_authProvider", void 0);
tslib_1.__decorate([
    shared_utils_1.Enumerable(false)
], SingleUserPubSubClient.prototype, "_pubSubClient", void 0);
SingleUserPubSubClient = SingleUserPubSubClient_1 = tslib_1.__decorate([
    common_1.rtfm('pubsub', 'SingleUserPubSubClient')
], SingleUserPubSubClient);
exports.SingleUserPubSubClient = SingleUserPubSubClient;
