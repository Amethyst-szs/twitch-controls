var SingleUserPubSubClient_1;
import { __decorate } from "tslib";
import { Enumerable } from '@d-fischer/shared-utils';
import { getValidTokenFromProvider, InvalidTokenTypeError } from '@twurple/auth';
import { extractUserId, rtfm } from '@twurple/common';
import { BasicPubSubClient } from "./BasicPubSubClient.mjs";
import { PubSubAutoModQueueMessage } from "./messages/PubSubAutoModQueueMessage.mjs";
import { PubSubBitsBadgeUnlockMessage } from "./messages/PubSubBitsBadgeUnlockMessage.mjs";
import { PubSubBitsMessage } from "./messages/PubSubBitsMessage.mjs";
import { PubSubChatModActionMessage } from "./messages/PubSubChatModActionMessage.mjs";
import { PubSubCustomMessage } from "./messages/PubSubCustomMessage.mjs";
import { PubSubRedemptionMessage } from "./messages/PubSubRedemptionMessage.mjs";
import { PubSubSubscriptionMessage } from "./messages/PubSubSubscriptionMessage.mjs";
import { PubSubUserModerationNotificationMessage } from "./messages/PubSubUserModerationNotificationMessage.mjs";
import { PubSubWhisperMessage } from "./messages/PubSubWhisperMessage.mjs";
import { PubSubListener } from "./PubSubListener.mjs";
/**
 * A higher level PubSub client attached to a single user.
 */
let SingleUserPubSubClient = SingleUserPubSubClient_1 = class SingleUserPubSubClient {
    /**
     * Creates a new Twitch PubSub client.
     *
     * @expandParams
     */
    constructor({ authProvider, pubSubClient, logger }) {
        this._listeners = new Map();
        this._authProvider = authProvider;
        this._pubSubClient = pubSubClient !== null && pubSubClient !== void 0 ? pubSubClient : new BasicPubSubClient({ logger });
        this._pubSubClient.onMessage(async (topic, messageData) => {
            const [type, userId, ...args] = topic.split('.');
            if (this._listeners.has(topic) && userId === (await this._getUserId())) {
                const message = SingleUserPubSubClient_1._parseMessage(type, args, messageData);
                for (const listener of this._listeners.get(topic)) {
                    listener.call(message);
                }
            }
        });
    }
    /**
     * Adds a listener to AutoMod queue events to the client.
     *
     * @param channel The channel to listen to.
     * @param callback A function to be called when an AutoMod queue event is sent to the user.
     *
     * It receives a {@PubSubAutoModQueueMessage} object.
     */
    async onAutoModQueue(channel, callback) {
        return await this._addListener('automod-queue', callback, 'channel:moderate', extractUserId(channel));
    }
    /**
     * Adds a listener to bits events to the client.
     *
     * @param callback A function to be called when a bits event happens in the user's channel.
     *
     * It receives a {@PubSubBitsMessage} object.
     */
    async onBits(callback) {
        return await this._addListener('channel-bits-events-v2', callback, 'bits:read');
    }
    /**
     * Adds a listener to bits badge unlock events to the client.
     *
     * @param callback A function to be called when a bit badge is unlocked in the user's channel.
     *
     * It receives a {@PubSubBitsBadgeUnlockMessage} object.
     */
    async onBitsBadgeUnlock(callback) {
        return await this._addListener('channel-bits-badge-unlocks', callback, 'bits:read');
    }
    /**
     * Adds a listener to mod action events to the client.
     *
     * @param channel The channel to listen to.
     * @param callback A function to be called when a mod action event is sent to the user.
     *
     * It receives a {@PubSubChatModActionMessage} object.
     */
    async onModAction(channel, callback) {
        return await this._addListener('chat_moderator_actions', callback, 'channel:moderate', extractUserId(channel));
    }
    /**
     * Adds a listener to redemption events to the client.
     *
     * @param callback A function to be called when a channel point reward is redeemed in the user's channel.
     *
     * It receives a {@PubSubRedemptionMessage} object.
     */
    async onRedemption(callback) {
        return await this._addListener('channel-points-channel-v1', callback, 'channel:read:redemptions');
    }
    /**
     * Adds a listener to user moderation events to the client.
     *
     * @param channel The channel to listen to.
     * @param callback A function to be called when a user moderation event is sent to the user.
     *
     * It receives a {@PubSubUserModerationNotificationMessage} object.
     */
    async onUserModeration(channel, callback) {
        return await this._addListener('user-moderation-notifications', callback, 'chat:read', extractUserId(channel));
    }
    /**
     * Adds a listener to subscription events to the client.
     *
     * @param callback A function to be called when a subscription event happens in the user's channel.
     *
     * It receives a {@PubSubSubscriptionMessage} object.
     */
    async onSubscription(callback) {
        return await this._addListener('channel-subscribe-events-v1', callback, 'channel_subscriptions');
    }
    /**
     * Adds a listener to whisper events to the client.
     *
     * @param callback A function to be called when a whisper is sent to the user.
     *
     * It receives a {@PubSubWhisperMessage} object.
     */
    async onWhisper(callback) {
        return await this._addListener('whispers', callback, 'whispers:read');
    }
    /**
     * Adds a listener for arbitrary/undocumented events to the client.
     *
     * @param topic The topic to subscribe to.
     * @param callback A function to be called when a custom event is sent to the user.
     *
     * It receives a {@PubSubCustomMessage} object.
     * @param scope An optional scope if the topic requires it.
     * @param channelId The ID of the channel to listen to, if the topic requires it.
     */
    async onCustomTopic(topic, callback, scope, channelId) {
        if (channelId) {
            return await this._addListener(topic, callback, scope, extractUserId(channelId));
        }
        else {
            return await this._addListener(topic, callback, scope);
        }
    }
    /**
     * Removes a listener from the client.
     *
     * @param listener A listener returned by one of the `add*Listener` methods.
     */
    async removeListener(listener) {
        if (this._listeners.has(listener.topic)) {
            const newListeners = this._listeners.get(listener.topic).filter(l => l !== listener);
            if (newListeners.length === 0) {
                this._listeners.delete(listener.topic);
                await this._pubSubClient.unlisten(`${listener.topic}.${listener.userId}`);
                if (!this._pubSubClient.hasAnyTopics &&
                    (this._pubSubClient.isConnected || this._pubSubClient.isConnecting)) {
                    await this._pubSubClient.disconnect();
                }
            }
            else {
                this._listeners.set(listener.topic, newListeners);
            }
        }
    }
    static _parseMessage(type, args, messageData) {
        switch (type) {
            case 'automod-queue': {
                return new PubSubAutoModQueueMessage(messageData, args[0]);
            }
            case 'channel-bits-events-v2': {
                return new PubSubBitsMessage(messageData);
            }
            case 'channel-bits-badge-unlocks': {
                return new PubSubBitsBadgeUnlockMessage(messageData);
            }
            case 'channel-points-channel-v1': {
                return new PubSubRedemptionMessage(messageData);
            }
            case 'channel-subscribe-events-v1': {
                return new PubSubSubscriptionMessage(messageData);
            }
            case 'chat_moderator_actions': {
                return new PubSubChatModActionMessage(messageData, args[0]);
            }
            case 'user-moderation-notifications': {
                return new PubSubUserModerationNotificationMessage(messageData, args[0]);
            }
            case 'whispers': {
                return new PubSubWhisperMessage(messageData);
            }
            default:
                return new PubSubCustomMessage(messageData);
        }
    }
    async _getUserId() {
        if (this._userId) {
            return this._userId;
        }
        const { tokenInfo } = await getValidTokenFromProvider(this._authProvider);
        if (!tokenInfo.userId) {
            throw new InvalidTokenTypeError('Could not determine a user ID for your token; you might be trying to disguise an app token as a user token.');
        }
        return (this._userId = tokenInfo.userId);
    }
    async _addListener(type, callback, scope, ...additionalParams) {
        await this._pubSubClient.connect();
        const userId = await this._getUserId();
        const topicName = [type, userId, ...additionalParams].join('.');
        const listener = new PubSubListener(topicName, userId, callback, this);
        if (this._listeners.has(topicName)) {
            this._listeners.get(topicName).push(listener);
        }
        else {
            this._listeners.set(topicName, [listener]);
            await this._pubSubClient.listen(topicName, this._authProvider, scope);
        }
        return listener;
    }
};
__decorate([
    Enumerable(false)
], SingleUserPubSubClient.prototype, "_authProvider", void 0);
__decorate([
    Enumerable(false)
], SingleUserPubSubClient.prototype, "_pubSubClient", void 0);
SingleUserPubSubClient = SingleUserPubSubClient_1 = __decorate([
    rtfm('pubsub', 'SingleUserPubSubClient')
], SingleUserPubSubClient);
export { SingleUserPubSubClient };
